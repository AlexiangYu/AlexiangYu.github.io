<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Alexiang&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="I love to share my thoughts and experiences about technology, programming and life.">
<meta property="og:type" content="website">
<meta property="og:title" content="Alexiang&#39;s Blog">
<meta property="og:url" content="https://alexiangyu.github.io/index.html">
<meta property="og:site_name" content="Alexiang&#39;s Blog">
<meta property="og:description" content="I love to share my thoughts and experiences about technology, programming and life.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Alexiang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Alexiang's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Alexiang&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">A little bit of everything</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://alexiangyu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-lc/11盛最多水的容器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/18/lc/11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2025-06-17T16:00:00.000Z" itemprop="datePublished">2025-06-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/18/lc/11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/">11盛最多水的容器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。</p>
<p>说明：你不能倾斜容器。</p>
<p>示例 1：</p>
<p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p>示例 2：</p>
<p>输入：height &#x3D; [1,1]<br>输出：1</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>这道题的思路是使用双指针，分别指向数组的左右两端，然后计算这两个指针所指向的两条线的面积，取最大值，然后移动指针指向较短的那条线，直到两指针相遇。</p>
<p>每次移动对应数字较小的那个指针，才能保证容器有可能变大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=height.<span class="built_in">size</span>()<span class="number">-1</span>, res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">            res= height[i]&lt;height[j]? <span class="built_in">max</span>(res, (j-i)*height[i++]):<span class="built_in">max</span>(res, (j-i)*height[j--]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiangyu.github.io/2025/06/18/lc/11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/" data-id="cmc102336000sc0vzbnq1hzl9" data-title="11盛最多水的容器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-lc/42接雨水" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/18/lc/42%E6%8E%A5%E9%9B%A8%E6%B0%B4/" class="article-date">
  <time class="dt-published" datetime="2025-06-17T16:00:00.000Z" itemprop="datePublished">2025-06-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/18/lc/42%E6%8E%A5%E9%9B%A8%E6%B0%B4/">42接雨水</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>示例 1：</p>
<p>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>
<p>示例 2：</p>
<p>输入：height &#x3D; [4,2,0,3,2,5]<br>输出：9</p>
<p>提示：</p>
<p>n &#x3D;&#x3D; height.length<br>1 &lt;&#x3D; n &lt;&#x3D; 2 * 104<br>0 &lt;&#x3D; height[i] &lt;&#x3D; 105</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>双指针解法，将空间复杂度降到 <code>O(1)</code>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        ans = l_val = r_val = <span class="number">0</span>     <span class="comment"># 左右两侧最大高度确定降水量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            l_val, r_val = <span class="built_in">max</span>(l_val, height[l]), <span class="built_in">max</span>(r_val, height[r]) <span class="comment"># 移动后更新</span></span><br><span class="line">            <span class="keyword">if</span> height[l] &lt; height[r]:   <span class="comment"># 移动较低的一侧</span></span><br><span class="line">                ans += l_val - height[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += r_val - height[r]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiangyu.github.io/2025/06/18/lc/42%E6%8E%A5%E9%9B%A8%E6%B0%B4/" data-id="cmc102339000xc0vzg7l45vtz" data-title="42接雨水" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-lc/3170删除星号以后字典序最小的字符串" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/17/lc/3170%E5%88%A0%E9%99%A4%E6%98%9F%E5%8F%B7%E4%BB%A5%E5%90%8E%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
  <time class="dt-published" datetime="2025-06-17T07:48:03.000Z" itemprop="datePublished">2025-06-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/17/lc/3170%E5%88%A0%E9%99%A4%E6%98%9F%E5%8F%B7%E4%BB%A5%E5%90%8E%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/">3298统计重新排列后包含另一个字符串的子字符串数目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lexicographically-minimum-string-after-removing-stars/description/">3298. 统计重新排列后包含另一个字符串的子字符串数目</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s 。它可能包含任意数量的 ‘<em>‘ 字符。你的任务是删除所有的 ‘</em>‘ 字符。</p>
<p>当字符串还存在至少一个 ‘*’ 字符时，你可以执行以下操作：</p>
<p>删除最左边的 ‘<em>‘ 字符，同时删除该星号字符左边一个字典序 最小 的字符。如果有多个字典序最小的字符，你可以删除它们中的任意一个。<br>请你返回删除所有 ‘</em>‘ 字符以后，剩余字符连接而成的 字典序最小 的字符串。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “aaba*”</p>
<p>输出：”aab”</p>
<p>解释：</p>
<p>删除 ‘*’ 号和它左边的其中一个 ‘a’ 字符。如果我们选择删除 s[3] ，s 字典序最小。</p>
<p>示例 2：</p>
<p>输入：s &#x3D; “abc”</p>
<p>输出：”abc”</p>
<p>解释：</p>
<p>字符串中没有 ‘*’ 字符。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s 只含有小写英文字母和 ‘<em>‘ 字符。<br>输入保证操作可以删除所有的 ‘</em>‘ 字符。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>根据贪心原则，为了让左侧串字典序尽量小，应该删去最后面的字符。</p>
<p>对字符串进行处理时，使用字典保存当前已遍历过的每种字符的索引，其中第 <code>k</code> 个栈维护第 <code>k</code> 个小写字母的索引。</p>
<p>当遇到字符 ‘∗’ 时，找到非空且字典序最小的栈，在字符串 s 种标记栈顶元素对应的字符为 ‘∗’，并移除栈顶元素；<br>当遇到非字符 ‘∗’ 时，则将当前索引 i 压入到对应的栈。</p>
<p>另外可用一个小根堆来维护出现的字符。最后，将堆中的字符按照出现的顺序连接起来，并按照字典序排序。</p>
<p>时间复杂度：<code>O(n*|Σ|)</code>，<code>n</code> 是字符串的长度，<code>|Σ|</code> 为字符集合的大小，本题字符均为小写字母，所以 <code>|Σ| = 26</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clearStars</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        chrHp = []</span><br><span class="line">        cnt = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                cnt[lc := chrHp[<span class="number">0</span>]].pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cnt[lc]:</span><br><span class="line">                    heappop(chrHp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt[c].append(i)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(cnt[c]) == <span class="number">1</span>:</span><br><span class="line">                    heappush(chrHp, c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(s.__getitem__, <span class="built_in">sorted</span>(<span class="built_in">sum</span>(cnt.values(), []))))        </span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiangyu.github.io/2025/06/17/lc/3170%E5%88%A0%E9%99%A4%E6%98%9F%E5%8F%B7%E4%BB%A5%E5%90%8E%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/" data-id="cmc102337000tc0vz25ah9xzv" data-title="3298统计重新排列后包含另一个字符串的子字符串数目" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-lc/优质章节连续选择" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/18/lc/%E4%BC%98%E8%B4%A8%E7%AB%A0%E8%8A%82%E8%BF%9E%E7%BB%AD%E9%80%89%E6%8B%A9/" class="article-date">
  <time class="dt-published" datetime="2025-01-18T06:54:23.000Z" itemprop="datePublished">2025-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/01/18/lc/%E4%BC%98%E8%B4%A8%E7%AB%A0%E8%8A%82%E8%BF%9E%E7%BB%AD%E9%80%89%E6%8B%A9/">优质章节连续选择</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在番茄小说的书籍中，编辑小S正在寻找精彩的连续章节以进行特色展示。每个章节都有各自的文字数量，编辑希望选出的连续章节总字数不超过 k。在这些连续章节中，除了第一章和最后一章，任何字数多于前后章节的章节都被视为优质章节。编辑的目标是挑选出尽可能多的优质章节，同时满足总字数限制。如果有多个答案优质章节数相同，请输出总字数最少的答案。优质章节数和总字数均相同，则输出区间下标最小的答案。</p>
<p>例如，假设章节字数为 [1000, 3000, 2000, 4000, 3000, 2000, 4000, 2000]，给定的字数上限 k 为 15000。一种优选方案是选择从第1章到第5章，其中第2章和第4章是优质章节。</p>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><p>n：章节数目<br>k：总字数上限<br>array_a：各个章节的字数</p>
<h2 id="返回规则如下："><a href="#返回规则如下：" class="headerlink" title="返回规则如下："></a>返回规则如下：</h2><p>返回一个字符串，格式为”优质章节数,优质章节数最多的区间左下标,优质章节数最多的区间右下标”</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>贪心 + 非典型的双指针</p>
<p>用 <code>flag</code> 数组标记优质章节，如 <code>[1000, 3000, 2000, 4000, 3000, 2000, 4000, 2000]</code> 对应为 <code>flag = [0, 1, 0, 1, 0, 0, 1, 0]</code> 。<br>由于要找总字数最少的答案，仅需考虑子章节 <code>l</code> 点在优质章节的左边，<code>r</code> 点在优质章节的右边之情况。<br>初始时区间放在第一个优质章节两侧，之后逐个平移左指针到下一节点，移动右指针到最大的 <code>current_sum</code> 字数时记录更新答案。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">n, k, array_a</span>):</span><br><span class="line">    flag = [<span class="number">0</span>] * n  <span class="comment"># 优质章节标志</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> array_a[i] &gt; array_a[i - <span class="number">1</span>] <span class="keyword">and</span> array_a[i] &gt; array_a[i + <span class="number">1</span>]:</span><br><span class="line">            flag[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始移动指针到优秀节点前后</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> flag[i]:</span><br><span class="line">            l, r = i - <span class="number">1</span>, i + <span class="number">1</span></span><br><span class="line">            current_sum = <span class="built_in">sum</span>(array_a[l: r+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    min_current_sum = k             <span class="comment"># 总字数</span></span><br><span class="line">    max_quality_count, quality_count = <span class="number">0</span>, <span class="number">1</span>    <span class="comment"># 优质章节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先移左指针</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; n-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> flag[l+<span class="number">1</span>]:   <span class="comment"># 右指针到达相应位置</span></span><br><span class="line">            <span class="keyword">while</span> current_sum &lt;= k <span class="keyword">and</span> r &lt; n:</span><br><span class="line">                <span class="keyword">if</span> flag[r-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> quality_count &gt; max_quality_count <span class="keyword">or</span> current_sum &lt; min_current_sum <span class="keyword">and</span> quality_count == max_quality_count:   <span class="comment"># 更新答案的条件</span></span><br><span class="line">                        max_quality_count = quality_count</span><br><span class="line">                        min_current_sum = current_sum</span><br><span class="line">                        best_l, best_r = l, r</span><br><span class="line">                r += <span class="number">1</span>  <span class="comment"># 右移并更新</span></span><br><span class="line">                <span class="keyword">if</span>  r &lt; n:</span><br><span class="line">                    quality_count += flag[r]</span><br><span class="line">                    current_sum += array_a[r]</span><br><span class="line">        </span><br><span class="line">        quality_count -= flag[l]    <span class="comment"># 左指针前进</span></span><br><span class="line">        current_sum -= array_a[l]</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;max_quality_count&#125;</span>,<span class="subst">&#123;best_l + <span class="number">1</span>&#125;</span>,<span class="subst">&#123;best_r + <span class="number">1</span>&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#  You can add more test cases here</span></span><br><span class="line">    <span class="built_in">print</span>(solution(<span class="number">8</span>, <span class="number">15000</span>, [<span class="number">1000</span>, <span class="number">3000</span>, <span class="number">2000</span>, <span class="number">4000</span>, <span class="number">3000</span>, <span class="number">2000</span>, <span class="number">4000</span>, <span class="number">2000</span>]) == <span class="string">&quot;2,1,5&quot;</span> )</span><br><span class="line">    <span class="built_in">print</span>(solution(<span class="number">8</span>, <span class="number">15000</span>, [<span class="number">2000</span>, <span class="number">5000</span>, <span class="number">2000</span>, <span class="number">1000</span>, <span class="number">4000</span>, <span class="number">2000</span>, <span class="number">4000</span>, <span class="number">3000</span>]) == <span class="string">&quot;2,4,8&quot;</span> )</span><br><span class="line">    <span class="built_in">print</span>(solution(<span class="number">10</span>, <span class="number">5000</span>, [<span class="number">500</span>,<span class="number">1000</span>,<span class="number">1500</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">1000</span>,<span class="number">1500</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">1000</span>]) == <span class="string">&quot;1,2,4&quot;</span> )</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiangyu.github.io/2025/01/18/lc/%E4%BC%98%E8%B4%A8%E7%AB%A0%E8%8A%82%E8%BF%9E%E7%BB%AD%E9%80%89%E6%8B%A9/" data-id="cmc10233a000zc0vz2m010kt9" data-title="优质章节连续选择" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-lc/76最小覆盖子串" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/11/lc/76%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/" class="article-date">
  <time class="dt-published" datetime="2025-01-11T14:17:04.000Z" itemprop="datePublished">2025-01-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/01/11/lc/76%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/">76最小覆盖子串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 “” 。</p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p>示例 1：</p>
<p>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>输出：”BANC”<br>解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、’B’ 和 ‘C’。</p>
<p>示例 2：</p>
<p>输入：s &#x3D; “a”, t &#x3D; “a”<br>输出：”a”<br>解释：整个字符串 s 是最小覆盖子串。</p>
<p>示例 3:</p>
<p>输入: s &#x3D; “a”, t &#x3D; “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>要确定一个滑动窗口，使用记录一个哈希表 <code>gap</code> 记录 <code>t</code> 中与目标字母数出现次数之差距，<code>gap</code> 为其总数。<br>向右移动 r 端点，对当前字符加入计数，直到 <code>gap == 0</code> 时窗口中字符已覆盖 <code>t</code>。此时记录更短的子串，并向右移动 l 端点缩小窗口，循环判定是否涵盖。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"></span><br><span class="line">        cnt = defaultdict(<span class="built_in">int</span>)  <span class="comment"># t 中出现的字母计数</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">            cnt[c] += <span class="number">1</span></span><br><span class="line">        gap = <span class="built_in">len</span>(cnt)  <span class="comment"># t 中的字母出现次数 - 窗口中字母数</span></span><br><span class="line"></span><br><span class="line">        ans_l, ans_r = -<span class="number">1</span>, <span class="built_in">len</span>(s)</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):  <span class="comment"># 子串右端点移动</span></span><br><span class="line">            cnt[c] -= <span class="number">1</span>     <span class="comment"># c 的出现次数差 - 1</span></span><br><span class="line">            <span class="keyword">if</span> cnt[c] == <span class="number">0</span>:     <span class="comment"># 已达成 t 中 c 的次数</span></span><br><span class="line">                gap -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> gap == <span class="number">0</span>:  <span class="comment"># 涵盖</span></span><br><span class="line">                <span class="keyword">if</span> r - l &lt; ans_r - ans_l:  <span class="comment"># 找到更短的子串</span></span><br><span class="line">                    ans_l, ans_r = l, r</span><br><span class="line">                <span class="keyword">if</span> cnt[s[l]] == <span class="number">0</span>:  <span class="comment"># 左端点移出窗口之前，检查出现次数</span></span><br><span class="line">                    gap += <span class="number">1</span></span><br><span class="line">                cnt[s[l]] += <span class="number">1</span>  <span class="comment"># 左端点字母移出子串</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> <span class="keyword">if</span> ans_l &lt; <span class="number">0</span> <span class="keyword">else</span> s[ans_l: ans_r + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>


<ul>
<li>想到可开一个栈保存右侧超过 <code>t</code> 串的字符，之后缩小窗口时可以眺移 l 端点。但需要更多内存开销并无益将 <code>O(n)</code> 的时间复杂度降低更多，故不采用。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiangyu.github.io/2025/01/11/lc/76%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/" data-id="cmc10233d0014c0vzb0jy45gb" data-title="76最小覆盖子串" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-lc/3298重新排列后包含另一个字符串的子字符串数目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/11/lc/3298%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%90%8E%E5%8C%85%E5%90%AB%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2025-01-11T14:17:04.000Z" itemprop="datePublished">2025-01-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/01/11/lc/3298%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%90%8E%E5%8C%85%E5%90%AB%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%9B%AE/">3298统计重新排列后包含另一个字符串的子字符串数目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii/description/">3298. 统计重新排列后包含另一个字符串的子字符串数目 II</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个字符串 <code>word1</code> 和 <code>word2</code> ，都只包含小写英文字母。</p>
<p>如果一个字符串 <code>x</code> 重新排列后，<code>word2</code> 是重排字符串的 前缀 ，那么我们称字符串 <code>x</code> 是 合法的 。<br>请你返回 <code>word1</code> 中 合法 子字符串 的数目。</p>
<p>实现一个线性复杂度的解法。</p>
<p>示例 1：</p>
<p>输入：<code>word1 = &quot;bcca&quot;, word2 = &quot;abc&quot;</code></p>
<p>输出：<code>1</code></p>
<p>解释：</p>
<p>唯一合法的子字符串是 <code>&quot;bcca&quot;</code> ，可以重新排列得到 <code>&quot;abcc&quot;</code> ，<code>&quot;abc&quot;</code> 是它的前缀。</p>
<p>示例 2：</p>
<p>输入：<code>word1 = &quot;abcabc&quot;, word2 = &quot;abc&quot;</code></p>
<p>输出：<code>10</code></p>
<p>解释：</p>
<p>除了长度为 1 和 2 的所有子字符串都是合法的。</p>
<p>示例 3：</p>
<p>输入：<code>word1 = &quot;abcabc&quot;, word2 = &quot;aaabc&quot;</code></p>
<p>输出：<code>0</code></p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>滑动窗口的内层循环结束时，右端点固定在 <code>right</code>，左端点在 0, 1, 2, …, left−1 的所有子串都是合法的，这一共有 <code>left</code> 个，把 <code>left</code> 加入答案</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validSubstringCount</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> word2:</span><br><span class="line">            cnt[<span class="built_in">ord</span>(x) - <span class="number">97</span>] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ans = l = <span class="number">0</span></span><br><span class="line">        less = <span class="built_in">sum</span>(x &lt; <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> cnt)  <span class="comment"># 相差字母计数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> word1:</span><br><span class="line">            x = <span class="built_in">ord</span>(x) - <span class="number">97</span></span><br><span class="line">            cnt[x] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt[x] == <span class="number">0</span>:</span><br><span class="line">                less -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> less == <span class="number">0</span>:        <span class="comment"># 移动右端点</span></span><br><span class="line">                y = <span class="built_in">ord</span>(word1[l]) - <span class="number">97</span></span><br><span class="line">                <span class="keyword">if</span> cnt[y] == <span class="number">0</span>:</span><br><span class="line">                    less += <span class="number">1</span></span><br><span class="line">                cnt[y] -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            ans += l</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiangyu.github.io/2025/01/11/lc/3298%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%90%8E%E5%8C%85%E5%90%AB%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%9B%AE/" data-id="cmc10233f001ac0vz2nll7zua" data-title="3298统计重新排列后包含另一个字符串的子字符串数目" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-lc/验证构造回文字符串" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/08/lc/%E9%AA%8C%E8%AF%81%E6%9E%84%E9%80%A0%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
  <time class="dt-published" datetime="2025-01-07T18:43:02.000Z" itemprop="datePublished">2025-01-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/01/08/lc/%E9%AA%8C%E8%AF%81%E6%9E%84%E9%80%A0%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/">验证构造回文字符串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小C手中有一个由小写字母组成的字符串 <code>s</code>。她希望构造另一个字符串 <code>t</code>，并且这个字符串需要满足以下几个条件：</p>
<ol>
<li>t 由小写字母组成，且长度与 <code>s</code> 相同。</li>
<li>t 是回文字符串，即从左到右与从右到左读取相同。</li>
<li>t 的字典序要小于 <code>s</code>，并且在所有符合条件的字符串中字典序尽可能大。</li>
</ol>
<p>小C想知道是否能构造出这样的字符串 <code>t</code>，输出这样的 <code>t</code>。如果无法构造满足条件的字符串，则输出 <code>-1</code></p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>关于字符串处理和贪心实现，时间复杂度 <code>O(n)</code></p>
<p>思路简单但情况比较繁琐，改了一阵子后才AC。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">int</span>((<span class="built_in">len</span>(s) + <span class="number">1</span>)/<span class="number">2</span>) <span class="comment"># 回文串前半截长度</span></span><br><span class="line">    pref = s[:n]</span><br><span class="line">    <span class="keyword">if</span> s[n:] &lt;= s[<span class="built_in">len</span>(s)-n-<span class="number">1</span>:: -<span class="number">1</span>]: <span class="comment"># 当翻转后的字典序不比原来的后一半小</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):    <span class="comment"># 找到第一个比 a 大的位置</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                pref = s[:i] + <span class="built_in">chr</span>(<span class="built_in">ord</span>(s[i]) - <span class="number">1</span>) + <span class="string">&#x27;z&#x27;</span> * (n-i-<span class="number">1</span>) <span class="comment"># 该位字典序 -1，后面的用 z 填充确保尽可能大</span></span><br><span class="line">                <span class="keyword">return</span> (pref + pref[<span class="built_in">len</span>(s) - n -<span class="number">1</span>:: -<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;-1&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (pref + pref[<span class="built_in">len</span>(s) - n -<span class="number">1</span>:: -<span class="number">1</span>])    <span class="comment"># 可以直接将前半截翻转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(solution(<span class="string">&quot;abc&quot;</span>) == <span class="string">&#x27;aba&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(solution(<span class="string">&quot;cba&quot;</span>) == <span class="string">&#x27;cac&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(solution(<span class="string">&quot;aaa&quot;</span>) == <span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(solution(<span class="string">&quot;aaabbbbcaaaccaba&quot;</span>) == <span class="string">&quot;aaabbbbbbbbbbaaa&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(solution(<span class="string">&quot;bbbbbaa&quot;</span>) == <span class="string">&quot;bbbabbb&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(solution(<span class="string">&quot;cbcaacb&quot;</span>) == <span class="string">&quot;cbbzbbc&quot;</span>)</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiangyu.github.io/2025/01/08/lc/%E9%AA%8C%E8%AF%81%E6%9E%84%E9%80%A0%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/" data-id="cmc10233e0018c0vzgrat9by7" data-title="验证构造回文字符串" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A8%A1%E6%8B%9F/" rel="tag">模拟</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-lc/最大子段和" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/06/lc/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/" class="article-date">
  <time class="dt-published" datetime="2025-01-06T15:59:26.000Z" itemprop="datePublished">2025-01-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/01/06/lc/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/">最大子段和</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><del>在洛谷做的第一道题qwq</del></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个整数，表示序列的长度 $n$。</p>
<p>第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数表示答案。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2 -4 3 -1 2 -4 3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><h4 id="样例-1-解释"><a href="#样例-1-解释" class="headerlink" title="样例 1 解释"></a>样例 1 解释</h4><p>选取 $[3, 5]$ 子段 ${3, -1, 2}$，其和为 $4$。</p>
<h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul>
<li>对于 $40%$ 的数据，保证 $n \leq 2 \times 10^3$。</li>
<li>对于 $100%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。</li>
</ul>
<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这是一个经典的动态规划问题，但也可以直接用前缀和+贪心解决。我们的思路：</p>
<p>可以把目标串视为连续的前后两个次子串相加，both of them should have a summation which is positive number. Otherwise it can be intercepted to increase the target string. 次子段和都要为正数，否则截掉会更优。即首末位都为正（长为1的次子串），而外边界为不大于零。这种情况下遍历一遍即可求解。</p>
<ol>
<li><p>维护两个变量：</p>
<ul>
<li><code>sum</code>: 当前累积的子段和</li>
<li><code>maxx</code>: 已经找到的最大子段和</li>
</ul>
</li>
<li><p>贪心策略：</p>
<ul>
<li>如果当前累积和 <code>sum</code> 为负数，那么抛弃之前的子段</li>
<li>将当前数字加入 <code>sum</code></li>
<li>若 <code>sum</code> 更大的话，更新 <code>maxx</code></li>
</ul>
</li>
<li><p>时间复杂度：O(n)，只需要遍历一遍数组</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> n, j, sum, maxx;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;maxx);</span><br><span class="line">	sum=maxx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(--n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;j);</span><br><span class="line">		sum = sum&gt;<span class="number">0</span> ? sum: <span class="number">0</span>;   <span class="comment">//贪心，如果负了就舍去 </span></span><br><span class="line">		sum += j;</span><br><span class="line">		maxx = maxx&gt;sum ? maxx: sum;    <span class="comment">// 维护最大值</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, maxx)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiangyu.github.io/2025/01/06/lc/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/" data-id="cmc10233c0013c0vz37vfcbo8" data-title="最大子段和" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E6%B2%BB/" rel="tag">分治</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" rel="tag">前缀和</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-lc/t0" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/06/lc/t0/" class="article-date">
  <time class="dt-published" datetime="2025-01-06T15:41:39.000Z" itemprop="datePublished">2025-01-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/01/06/lc/t0/">题解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>test…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiangyu.github.io/2025/01/06/lc/t0/" data-id="cmc102339000yc0vz1qt91kui" data-title="题解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据库系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-11-17T08:05:11.000Z" itemprop="datePublished">2024-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h3><p>在分布式系统中，不可能同时满足一致性（Consistency），可用性（Availability）和分区容错性（Partition tolerance），最多只能同时做到两个。</p>
<ul>
<li>Consistency（一致性）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。</li>
<li>Availability（可用性）：在集群中任意节点故障时，仍然可以提供服务。</li>
<li>Partition tolerance（分区容错性）：分布式系统在遇到网络分区故障时，仍然能够继续运行。</li>
</ul>
<h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><p>BASE 理论是对 CAP 理论的一种扩展，是 NoSQL 数据库通常选择的理论。</p>
<ul>
<li>Basically Available（基本可用）：不保证一致性，但保证可用性。</li>
<li>Soft state（软状态）：允许系统中的数据存在中间状态，并不保证数据的强一致性。</li>
<li>Eventually consistent（最终一致性）：系统中的数据经过一段时间的同步后，最终达到一致的状态。</li>
</ul>
<h3 id="典型问题"><a href="#典型问题" class="headerlink" title="典型问题"></a>典型问题</h3><ul>
<li>幂等性（Idempotence）某个操作可以执行多次，但执行的效果与执行一次是相同的。</li>
<li>互斥性（Mutual Exclusion）主要涉及在多个进程或线程并发执行时，对于共享资源的访问控制。互斥性确保在同一时刻只有一个进程能够访问共享资源，从而避免由于并发操作而导致的数据不一致或资源冲突。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiangyu.github.io/2024/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" data-id="cmc102335000nc0vz7sp2fh0s" data-title="数据库系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-使用LangChain构建LLMs应用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/09/%E4%BD%BF%E7%94%A8LangChain%E6%9E%84%E5%BB%BALLMs%E5%BA%94%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2024-11-09T07:37:33.000Z" itemprop="datePublished">2024-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/09/%E4%BD%BF%E7%94%A8LangChain%E6%9E%84%E5%BB%BALLMs%E5%BA%94%E7%94%A8/">使用LangChain构建LLMs应用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="LangChain功能总结"><a href="#LangChain功能总结" class="headerlink" title="LangChain功能总结"></a>LangChain功能总结</h2><ol>
<li>Model I&#x2F;O </li>
<li>RAG</li>
<li>Agent</li>
<li>Chain (LCEL)</li>
<li>Memory</li>
<li>Callbacks</li>
</ol>
<p><strong>使用 LCEL</strong></p>
<p>构造链 LangChain Expression Language 声明式表达方式，轻松组合多个步骤</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chain = prompt | model | output_parser</span><br><span class="line">result = chain.invoke(&#123;<span class="string">&quot;flower&quot;</span>: <span class="string">&quot;玫瑰&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本质上就是对各种大模型提供的API的套壳，是为了方便我们使用这些API，搭建起来的一些框架、模块和接口。</p>
<blockquote>
<p>LangChain是一个基于大语言模型（LLMs）用于构建端到端语言模型应用的框架，它可以让开发者使用语言模型来实现各种复杂的任务，例如文本到图像的生成、文档问答、聊天机器人等。LangChain提供了一系列工具、套件和接口，可以简化创建由LLMs和聊天模型提供支持的应用程序的过程。</p>
</blockquote>
<p><img src="/image/ff.webp" alt="alt text"></p>
<h2 id="Model-I-O-过程"><a href="#Model-I-O-过程" class="headerlink" title="Model I&#x2F;O 过程"></a>Model I&#x2F;O 过程</h2><p>输入提示（Format）-&gt; 调用模型（Predict）-&gt; 输出解析（Parse）</p>
<ol>
<li>提示模板：使用模型的第一个环节是把提示信息输入到模型中，你可以创建LangChain模板，根据实际需求动态选择不同的输入，针对特定的任务和应用调整输入。</li>
<li>语言模型：LangChain允许你通过通用接口来调用语言模型。这意味着无论你要使用的是哪种语言模型，都可以通过同一种方式进行调用，这样就提高了灵活性和便利性。</li>
<li>输出解析：LangChain还提供了从模型输出中提取信息的功能。通过输出解析器，你可以精确地从模型的输出中获取需要的信息，而不需要处理冗余或不相关的数据，更重要的是还可以把大模型给回的非结构化文本，转换成程序可以处理的结构化数据。</li>
</ol>
<p>LangChain中支持的三大类语言模型:</p>
<ol>
<li>大语言模型（LLM） ，即Text Model，这些模型将文本字符串作为输入，并返回文本字符串作为输出。</li>
<li>聊天模型（Chat Model），主要代表Open AI的ChatGPT系列模型。这些模型通常由语言模型支持，但它们的 API 更加结构化。具体来说，这些模型将聊天消息列表作为输入，并返回聊天消息。</li>
<li>文本嵌入模型（Embedding Model），这些模型将文本作为输入并返回浮点数列表，也就是Embedding。而文本嵌入模型如OpenAI的text-embedding-ada-002。文本嵌入模型负责把文档存入向量数据库。</li>
</ol>
<p>LangChain Agent（代理）实例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---- Part 0 导入所需要的类</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BlipProcessor, BlipForConditionalGeneration</span><br><span class="line"><span class="keyword">from</span> langchain.tools <span class="keyword">import</span> BaseTool</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> initialize_agent, AgentType</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- Part I 初始化图像字幕生成模型</span></span><br><span class="line"><span class="comment"># 指定要使用的工具模型（HuggingFace中的image-caption模型）</span></span><br><span class="line">hf_model = <span class="string">&quot;Salesforce/blip-image-captioning-large&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在初始化图像字幕生成模型...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化处理器和工具模型</span></span><br><span class="line"><span class="comment"># 预处理器将准备图像供模型使用</span></span><br><span class="line">processor = BlipProcessor.from_pretrained(hf_model)</span><br><span class="line"><span class="comment"># 然后我们初始化工具模型本身</span></span><br><span class="line">model = BlipForConditionalGeneration.from_pretrained(hf_model)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;初始化图像字幕生成模型成功&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- Part II 定义图像字幕生成工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageCapTool</span>(<span class="title class_ inherited__">BaseTool</span>):</span><br><span class="line">    name = <span class="string">&quot;Image captioner&quot;</span></span><br><span class="line">    description = <span class="string">&quot;使用该工具可以生成图片的文字描述，需要传入图片的URL.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run</span>(<span class="params">self, url: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="comment"># 下载图像并将其转换为PIL对象</span></span><br><span class="line">        image = Image.<span class="built_in">open</span>(requests.get(url, stream=<span class="literal">True</span>).raw).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">        <span class="comment"># 预处理图像</span></span><br><span class="line">        inputs = processor(image, return_tensors=<span class="string">&quot;pt&quot;</span>)</span><br><span class="line">        <span class="comment"># 生成字幕</span></span><br><span class="line">        out = model.generate(**inputs, max_new_tokens=<span class="number">200</span>)</span><br><span class="line">        <span class="comment"># 获取字幕</span></span><br><span class="line">        caption = processor.decode(out[<span class="number">0</span>], skip_special_tokens=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> caption</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_arun</span>(<span class="params">self, query: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;This tool does not support async&quot;</span>)</span><br><span class="line"></span><br><span class="line">agent = initialize_agent(</span><br><span class="line">    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,</span><br><span class="line">    tools=[ImageCapTool()],</span><br><span class="line">    llm=ChatOpenAI( model=os.environ.get(<span class="string">&quot;LLM_MODEL_4K_FUNCTION_CALL&quot;</span>), temperature=<span class="number">0</span>),</span><br><span class="line">    verbose=<span class="literal">True</span>,</span><br><span class="line">    handle_parsing_errors=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">img_url = <span class="string">&quot;https://youimg1.c-ctrip.com/target/100v1d000001ej8qh6217.jpg&quot;</span></span><br><span class="line">agent.run(<span class="built_in">input</span>=<span class="string">f&quot;<span class="subst">&#123;img_url&#125;</span>\n请创作合适的中文推广文案&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://python.langchain.com/docs/get_started">API 文档</a></p>
<h3 id="提示工程"><a href="#提示工程" class="headerlink" title="提示工程"></a>提示工程</h3><p>好的提示（其实也就是好的问题或指示啦），肯定能够让你在调用语言模型的时候事半功倍。</p>
<blockquote>
<p>GPT 最佳实践: </p>
<ol>
<li>写清晰的指示</li>
<li>给模型提供参考（也就是示例）</li>
<li>将复杂任务拆分成子任务</li>
<li>给GPT时间思考</li>
<li>使用外部工具</li>
<li>反复迭代问题</li>
</ol>
</blockquote>
<p>LangChain 提供了多个类和函数，也为各种应用场景设计了很多内置模板，使构建和使用提示变得容易。</p>
<blockquote>
<p>LangChain的优势所在：我们只需要定义一次模板，就可以用它来生成各种不同的提示。</p>
<p><code>PromptTemplate</code> 的 <code>from_template</code> 方法就是将一个原始的模板字符串转化为一个更丰富、更方便操作的 <code>PromptTemplate</code> 对象，这个对象就是LangChain中的提示模板。<br>LangChain中，<code>SemanticSimilarityExampleSelector</code> 对象可以根据语义相似性选择最相关的示例， <code>example_selector</code> 会根据语义的相似度（余弦相似度）找到最相似的示例</p>
</blockquote>
<p>提示框架：指令 + 上下文 + 提示输入 + 输出指示器</p>
<p>GPT-3模型，作为一个大型的自我监督学习模型，通过提升模型规模，实现了出色的<strong>Few-Shot</strong>学习性能。</p>
<p><img src="/image/357e9ca0ce2b4699a24e3fe512c047ca.webp" alt="alt text"></p>
<h4 id="使用-Chain-of-Thought"><a href="#使用-Chain-of-Thought" class="headerlink" title="使用 Chain of Thought"></a>使用 Chain of Thought</h4><p>《自我一致性提升了语言模型中的思维链推理能力》：如果生成一系列的中间推理步骤，就能够显著提高大型语言模型进行复杂推理的能力。</p>
<blockquote>
<p>Few-Shot CoT 简单的在提示中提供了一些链式思考示例（Chain-of-Thought Prompting），足够大的语言模型的推理能力就能够被增强。简单说，就是给出一两个示例，然后在示例中写清楚推导的过程。</p>
</blockquote>
<p>提供思考示例：问题理解 -&gt; 信息搜索 -&gt; 决策制定 -&gt; 生成结果列表</p>
<blockquote>
<p>Few-Shot CoT，指的就是在带有示例的提示过程中，加入思考的步骤，从而引导模型给出更好的结果。而 Zero-Shot CoT，就是直接告诉模型要一步一步地思考，慢慢地推理。</p>
</blockquote>
<blockquote>
<p>CoT 应当被用于 20B 以上参数规模的模型之中，并且模型的训练数据应当于任务问题相关且彼此相互有较强的联结。 首从工程的角度而言，CoT 的适用场景抽象一下可以被归纳为三点，分别是使用大模型（1），任务需要复杂推理（2），参数量的增加无法使得模型性能显著提升（3）。此外，现有的论文实验也表明，CoT 更加适合复杂的推理任务，比如计算或编程，不太适用于简单的单项选择、序列标记等任务之中，并且 CoT 并不适用于那些参数量较小的模型（20B以下），在小模型中使用 CoT 非常有可能会造成机器幻觉等等问题。 而从理论角度，一篇来自斯坦福的论文《Why think step-by-step? reasoning emerges from the locality of experience》揭示了<strong>当大模型的训练数据表现出了变量的局部簇结构（Local Clusters of Variables）</strong>时，CoT 将会展现极好的效果。而变量的局部簇主要指训练数据中变量之间有着强的相互作用，相互影响的关系。</p>
</blockquote>
<p>需要深度推理的复杂任务：dfs思维树（Tree of Thoughts，ToT）</p>
<blockquote>
<p>请你模拟三位出色、逻辑性强的专家合作回答一个问题。每个人都详细地解释他们的思考过程，考虑到其他人之前的解释，并公开承认错误。在每一步，只要可能，每位专家都会在其他人的思考基础上进行完善和建设，并承认他们的贡献。他们继续，直到对问题有一个明确的答案。为了清晰起见，您的整个回应应该是一个Markdown表格。   问题是…</p>
</blockquote>
<h3 id="调用-OpenAI-API"><a href="#调用-OpenAI-API" class="headerlink" title="调用 OpenAI API"></a>调用 OpenAI API</h3><ul>
<li>Text模型：<code>prompt</code> 与 <code>max_tokens</code> 参数控制生成的文本长度。简洁。</li>
<li>Chat模型：消息角色：<ul>
<li><code>system</code>：系统消息主要用于设定对话的背景或上下文。这可以帮助模型理解它在对话中的角色和任务。系统消息通常在对话开始时给出。</li>
<li><code>user</code>：用户消息是从用户或人类角色发出的。它们通常包含了用户想要模型回答或完成的请求。</li>
<li><code>assistant</code>：助手消息是模型的回复。发送多轮对话中新的对话请求时，可以通过助手消息提供先前对话的上下文。在对话的最后一条消息应始终为用户消息。</li>
</ul>
</li>
</ul>
<p>响应对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;chatcmpl-2nZI6v1cW9E3Jg4w2Xtoql0M3XHfH&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;object&#x27;</span>: <span class="string">&#x27;chat.completion&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;created&#x27;</span>: <span class="number">1677649420</span>,</span><br><span class="line"> <span class="string">&#x27;model&#x27;</span>: <span class="string">&#x27;gpt-4&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;usage&#x27;</span>: &#123;<span class="string">&#x27;prompt_tokens&#x27;</span>: <span class="number">56</span>, <span class="string">&#x27;completion_tokens&#x27;</span>: <span class="number">31</span>, <span class="string">&#x27;total_tokens&#x27;</span>: <span class="number">87</span>&#125;,</span><br><span class="line"> <span class="string">&#x27;choices&#x27;</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&#x27;message&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;role&#x27;</span>: <span class="string">&#x27;assistant&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;content&#x27;</span>: <span class="string">&#x27;你的花店可以叫做&quot;花香四溢&quot;。&#x27;</span></span><br><span class="line">     &#125;,</span><br><span class="line">    <span class="string">&#x27;finish_reason&#x27;</span>: <span class="string">&#x27;stop&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;index&#x27;</span>: <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>text</code>：生成的文本。</li>
<li><code>finish_reason</code>：模型停止生成的原因，可能的值包括 stop（遇到了停止标记）、length（达到了最大长度）或 temperature（根据设定的温度参数决定停止）。</li>
<li><code>created</code>：生成响应的时间戳。</li>
</ul>
<p>使用OpenAI API</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;你的OpenAI API Key&#x27;</span></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_BASE_URL&quot;] = &#x27;OpenAI 的 API URL&#x27;</span></span><br><span class="line"></span><br><span class="line">client = OpenAI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># text = client.invoke(&quot;请给我写一句情人节红玫瑰的中文宣传语&quot;)</span></span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">    model=os.environ.get(<span class="string">&quot;LLM_MODELEND&quot;</span>),</span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a creative AI.&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;请给我的花店起个名&quot;</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line">    temperature=<span class="number">0.8</span>,</span><br><span class="line">    max_tokens=<span class="number">600</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.choices[<span class="number">0</span>].message.content)</span><br></pre></td></tr></table></figure>

<p>通过 LangChain 调用</p>
<p>我们只需要定义一次模板，更简洁。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> HumanMessage, SystemMessage</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;你的OpenAI API Key&#x27;</span></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_BASE_URL&quot;] = &#x27;OpenAI 的 API URL&#x27;</span></span><br><span class="line"></span><br><span class="line">chat = ChatOpenAI(model=os.environ.get(<span class="string">&quot;LLM_MODELEND&quot;</span>), temperature=<span class="number">0.8</span>, max_tokens=<span class="number">600</span>)</span><br><span class="line"></span><br><span class="line">messages = [</span><br><span class="line">    SystemMessage(content=<span class="string">&quot;你是一个很棒的智能助手&quot;</span>),</span><br><span class="line">    HumanMessage(content=<span class="string">&quot;请给我的猫起个名&quot;</span>),</span><br><span class="line">]</span><br><span class="line">response = chat(messages)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>


<p><strong>预训练+微调的大模型应用模式</strong>：高效、扩展性</p>
<blockquote>
<p>微调（Fine-tuning）：对模型的头部或者部分参数根据自己的需要进行适应性的调整，这通常涉及在相对较小的有标注数据集上进行有监督学习，让模型适应特定任务的需求。<br>微调过程相比于从头训练一个模型要快得多，且需要的数据量也要少得多。</p>
</blockquote>
<ul>
<li>预训练：在大规模无标注文本数据上进行模型的训练，学习基本的特征和模式。</li>
<li>微调：快速地根据特定任务进行优化，使用标注好的数据集，以便模型能针对特定任务进行优化和调整。</li>
</ul>
<p>从HuggingFace下载并导入模型使用</p>
<h3 id="输出解析"><a href="#输出解析" class="headerlink" title="输出解析"></a>输出解析</h3><p>得到清晰的数据结构，方便将解析好的数据存入CSV文档。</p>
<p>输出解析器类要实现两个核心方法：</p>
<ul>
<li><code>get_format_instructions</code>：这个方法需要返回一个字符串，用于指导如何格式化语言模型的输出，告诉它应该如何组织并构建它的回答。</li>
<li><code>parse</code>：这个方法接收一个字符串（也就是语言模型的输出）并将其解析为特定的数据结构或格式。这一步通常用于确保模型的输出符合我们的预期，并且能够以需要的形式进行后续处理。</li>
<li><code>parse_with_prompt</code>：这个方法接收一个字符串（也就是语言模型的输出）和一个提示（用于生成这个输出的提示），并将其解析为特定的数据结构。这样，你可以根据原始提示来修正或重新解析模型的输出，确保输出的信息更加准确和贴合要求。</li>
</ul>
<blockquote>
<p>用 <code>output_parser.parse(output)</code> 把模型输出的文案解析成之前定义好的数据格式，也就是一个Python字典，这个字典中包含了 <code>description</code> 和 <code>reason</code> 这两个字段的值。</p>
</blockquote>
<p><strong>使用 Pydantic（JSON）解析器</strong>: 数据验证、数据转换</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;Your OpenAI API Key&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型实例</span></span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">model = ChatOpenAI(</span><br><span class="line">    model=os.environ.get(<span class="string">&quot;LLM_MODELEND&quot;</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------Part 2</span></span><br><span class="line"><span class="comment"># 创建一个空的DataFrame用于存储结果</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(columns=[<span class="string">&quot;flower_type&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="string">&quot;description&quot;</span>, <span class="string">&quot;reason&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">flowers = [<span class="string">&quot;玫瑰&quot;</span>, <span class="string">&quot;百合&quot;</span>, <span class="string">&quot;康乃馨&quot;</span>]</span><br><span class="line">prices = [<span class="string">&quot;50&quot;</span>, <span class="string">&quot;30&quot;</span>, <span class="string">&quot;20&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义我们想要接收的数据格式</span></span><br><span class="line"><span class="keyword">from</span> pydantic.v1 <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlowerDescription</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    flower_type: <span class="built_in">str</span> = Field(description=<span class="string">&quot;鲜花的种类&quot;</span>)</span><br><span class="line">    price: <span class="built_in">int</span> = Field(description=<span class="string">&quot;鲜花的价格&quot;</span>)</span><br><span class="line">    description: <span class="built_in">str</span> = Field(description=<span class="string">&quot;鲜花的描述文案&quot;</span>)</span><br><span class="line">    reason: <span class="built_in">str</span> = Field(description=<span class="string">&quot;为什么要这样写这个文案&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------Part 3</span></span><br><span class="line"><span class="comment"># 创建输出解析器</span></span><br><span class="line"><span class="keyword">from</span> langchain.output_parsers <span class="keyword">import</span> PydanticOutputParser</span><br><span class="line"></span><br><span class="line">output_parser = PydanticOutputParser(pydantic_object=FlowerDescription)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取输出格式指示</span></span><br><span class="line">format_instructions = output_parser.get_format_instructions()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出格式：&quot;</span>, format_instructions)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------Part 4</span></span><br><span class="line"><span class="comment"># 创建提示模板</span></span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">prompt_template = <span class="string">&quot;&quot;&quot;您是一位专业的鲜花店文案撰写员。</span></span><br><span class="line"><span class="string">对于售价为 &#123;price&#125; 元的 &#123;flower&#125; ，您能提供一个吸引人的简短中文描述吗？</span></span><br><span class="line"><span class="string">&#123;format_instructions&#125;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据模板创建提示，同时在提示中加入输出解析器的说明</span></span><br><span class="line">prompt = PromptTemplate.from_template(</span><br><span class="line">    prompt_template, partial_variables=&#123;<span class="string">&quot;format_instructions&quot;</span>: format_instructions&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印提示</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;提示：&quot;</span>, prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------Part 5</span></span><br><span class="line"><span class="keyword">for</span> flower, price <span class="keyword">in</span> <span class="built_in">zip</span>(flowers, prices):</span><br><span class="line">    <span class="comment"># 根据提示准备模型的输入</span></span><br><span class="line">    <span class="built_in">input</span> = prompt.<span class="built_in">format</span>(flower=flower, price=price)</span><br><span class="line">    <span class="comment"># 打印提示</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;提示：&quot;</span>, <span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取模型的输出</span></span><br><span class="line">    output = model.predict(<span class="built_in">input</span>)</span><br><span class="line">    <span class="comment"># 解析模型的输出</span></span><br><span class="line">    parsed_output = output_parser.parse(output)</span><br><span class="line">    parsed_output_dict = parsed_output.<span class="built_in">dict</span>()  <span class="comment"># 将Pydantic格式转换为字典</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将解析后的输出添加到DataFrame中</span></span><br><span class="line">    df.loc[<span class="built_in">len</span>(df)] = parsed_output.<span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输出的数据：&quot;</span>, df.to_dict(orient=<span class="string">&quot;records&quot;</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>自动修复解析器 <code>OutputFixingParser</code>：调用了原有的PydanticOutputParser，如果失败，它会将格式错误的输出以及格式化的指令传递给大模型，并要求LLM进行相关的修复。</li>
<li>重试解析器 <code>RetryWithErrorOutputParser</code>：利用大模型的推理能力根据原始提示找回相关信息。</li>
</ul>
<p>文档：LangChain中的各种 <a href="https://link.juejin.cn/?target=https://python.langchain.com/docs/modules/model_io/output_parsers/">Output Parsers</a></p>
<h2 id="Chain"><a href="#Chain" class="headerlink" title="Chain"></a>Chain</h2><blockquote>
<p>LangChain通过设计好的接口，实现一个具体的链的功能。例如，LLM链（LLMChain）能够接受用户输入，使用 PromptTemplate 对其进行格式化，然后将格式化的响应传递给 LLM。这就相当于把整个 Model I&#x2F;O 的流程封装到链里面；多个链组可以合在一起。</p>
</blockquote>
<p>多种类型的预置链：</p>
<ol>
<li><strong>LLMChain</strong>：这是最简单的链，主要用于处理基本的对话任务、文本生成等。它将输入文本传递给模型并输出结果。</li>
<li><strong>SequentialChain</strong>：将多个链顺序调用。每个链的输出可以作为下一个链的输入。</li>
<li><strong>TransformChain</strong>：对输入进行格式转换、分化</li>
<li><strong>RouterChain</strong>：根据输入的条件，选择不同的链。</li>
</ol>
<p><code>LLMChain</code> 围绕着语言模型推理功能又添加了一些功能，整合了 <code>PromptTemplate</code>、语言模型（LLM或聊天模型）和 <code>Output Parser</code>，相当于把Model I&#x2F;O放在一个链中整体操作。它使用提示模板格式化输入，将格式化的字符串传递给 LLM，并返回 LLM 输出。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate, OpenAI, LLMChain</span><br><span class="line"><span class="comment"># 原始字符串模板</span></span><br><span class="line">template = <span class="string">&quot;&#123;flower&#125;的花语是?&quot;</span></span><br><span class="line"><span class="comment"># 创建模型实例</span></span><br><span class="line">llm = OpenAI(temperature=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 创建LLMChain</span></span><br><span class="line">llm_chain = LLMChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    prompt=PromptTemplate.from_template(template))</span><br><span class="line"><span class="comment"># 调用LLMChain，返回结果</span></span><br><span class="line">result = llm_chain(<span class="string">&quot;玫瑰&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>路由链：构造提示信息，来引导大模型查看用户输入的问题并确定问题的类型的。</p>
<p><code>MultiPromptChain</code> 类把前几个链整合在一起，实现路由功能。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建多提示链</span></span><br><span class="line"><span class="keyword">from</span> langchain.chains.router <span class="keyword">import</span> MultiPromptChain</span><br><span class="line">chain = MultiPromptChain(</span><br><span class="line">    router_chain=router_chain,</span><br><span class="line">    destination_chains=chain_map,</span><br><span class="line">    default_chain=default_chain,</span><br><span class="line">    verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ConversationChain"><a href="#ConversationChain" class="headerlink" title="ConversationChain"></a>ConversationChain</h3><p>包含AI前缀与人类前缀的对话摘要格式，这个对话格式和记忆机制结合得非常紧密。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 打印对话的模板</span><br><span class="line">The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know. # 减少幻觉</span><br><span class="line"></span><br><span class="line">Current conversation:</span><br><span class="line">&#123;history&#125;</span><br><span class="line">Human: &#123;input&#125;</span><br><span class="line">AI:</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&#123;history&#125;</code> 是存储会话记忆的地方，也就是人类和人工智能之间对话历史的信息。</li>
<li><code>&#123;input&#125;</code> 是新输入的地方，你可以把它看成是和ChatGPT对话时，文本框中的输入。</li>
</ul>
<p>加入记忆功能：<code>conversation = ConversationChain(llm=llm, memory=ConversationBufferMemory())</code> 。聊天历史信息，都被传入了ConversationChain的提示模板中的 {history} 参数，构建出了包含聊天记录的新的提示输入。</p>
<ul>
<li><code>ConversationBufferWindowMemory</code>：缓冲窗口记忆，它的思路就是只保存最新最近的几次人类和AI的互动。因此，它在之前的“缓冲记忆”基础上增加了一个窗口值 <code>k</code>。这意味着我们只保留一定数量的过去互动，然后“忘记”之前的互动。</li>
<li><code>ConversationSummaryMemory</code>：使用LLM将对话历史进行汇总，然后再传递给 {history} 参数。这种方法旨在通过对之前的对话进行汇总来避免长对话过度使用Token。</li>
<li><code>ConversationSummaryBufferMemory</code>：混合记忆模型，当最新的对话文字长度在300字之内的时候，LangChain会记忆原始对话内容；当对话文字超出了这个参数的长度，那么模型就会把所有超过预设长度的内容进行总结。</li>
</ul>
<p><img src="/image/c56yyd7eb61637687de448512yy426ea.webp" alt="alt text"></p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>与外部环境交互，将额外信息合并到推理中。</p>
<ul>
<li>大模型：提供逻辑的引擎，负责生成预测和处理输入。</li>
<li>与之交互的外部工具：可能包括数据清洗工具、搜索引擎、应用程序等。</li>
<li>控制交互的<strong>代理</strong>：调用适当的外部工具，并管理整个交互过程的流程。</li>
</ul>
<h4 id="ReAct框架"><a href="#ReAct框架" class="headerlink" title="ReAct框架"></a>ReAct框架</h4><p>Reasoning-Acting框架：指导大语言模型推理和行动的一种思维框架。</p>
<p>行动 -&gt; 观察 -&gt; 思考 -&gt; 行动</p>
<p>《ReAct：在语言模型中协同推理和行动》：</p>
<blockquote>
<p>大语言模型可以通过生成推理痕迹和任务特定行动来实现更大的协同作用。<br>Reasoning包括了对当前环境和状态的观察，并生成推理轨迹。这使模型能够诱导、跟踪和更新操作计划，甚至处理异常情况。Acting在于指导大模型采取下一步的行动，比如与外部源（如知识库或环境）进行交互并且收集信息，或者给出最终答案。</p>
</blockquote>
<p><img src="/image/56fbe79e086052895f301383c27f4a0c.webp" alt="ReAct 思维链条"></p>
<blockquote>
<p>在链中，一系列操作被硬编码（在代码中）。在代理中，LLM被用作推理引擎来确定要采取哪些操作以及按什么顺序执行这些操作。</p>
</blockquote>
<p>思考框架：</p>
<blockquote>
<p>Use the following format:\n\n （指导模型使用下面的格式）<br>Question: the input question you must answer\n （问题）<br>Thought: you should always think about what to do\n （思考）<br>Action: the action to take, should be one of [Search, Calculator]\n （行动）<br>Action Input: the input to the action\n （行动的输入）<br>Observation: the result of the action\n… （观察：行动的返回结果）<br>(this Thought&#x2F;Action&#x2F;Action Input&#x2F;Observation can repeat N times)\n （上面这个过程可以重复多次）<br>Thought: I now know the final answer\n （思考：现在我知道最终答案了）<br>Final Answer: the final answer to the original input question\n\n （最终答案）</p>
</blockquote>
<p>根据现有知识解决不了，下一步行动是需要选择工具箱中的搜索工具：</p>
<blockquote>
<p>text: I need to find the current market price of roses and then calculate the new price with a 15% markup.\n （Text：问题文本）<br>Action: Search\n （行动：搜索）<br>Action Input: “Average price of roses” （行动的输入：搜索玫瑰平均价格）</p>
</blockquote>
<p>计算：</p>
<blockquote>
<p>AgentAction(tool&#x3D;’Calculator’, tool_input&#x3D;’80.16 * 1.15’, log&#x3D;’ I need to calculate the new price with a 15% markup.\nAction: Calculator\nAction Input: 80.16 * 1.15’)</p>
</blockquote>
<p>最后，AgentExcutor的plan方法返回一个 <code>AgentFinish</code> 实例，这表示代理经过对输出的检查，其内部逻辑判断出任务已经完成，思考和行动的循环要结束了。</p>
<blockquote>
<p>Thought: I now know the final answer. </p>
</blockquote>
<ul>
<li><p><strong>结构化工具对话代理</strong>（Structured Tool Chat）是一种通过预先设定的结构与用户进行交互的工具，可以有效引导对话的主题和内容。</p>
<ul>
<li>文件管理工具集</li>
<li>Web 浏览器工具集<ul>
<li><code>PlayWright</code> 工具包</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>自主询问搜索代理</strong>（Self-Ask with Search）利用一种叫做 “Follow-up Question（追问）”加“Intermediate Answer（中间答案）”的技巧，来辅助大模型寻找事实性问题的过渡性答案，从而引出最终答案。</p>
<ul>
<li>逐步逼近，以自己提问并搜索：<code>使用玫瑰作为国花的国家的首都是哪里? = 使用玫瑰作为国花的国家？ + 都铎王朝的首都在哪里？</code></li>
</ul>
</li>
<li><p><strong>计划与执行代理</strong>（Plan and Execute）是指能够根据用户的需求制定计划，并执行相应操作的工具，帮助用户实现特定的目标或任务。</p>
<ul>
<li>首先，制定一个计划，并将整个任务划分为更小的子任务；然后按照该计划执行子任务。<ul>
<li>计划由一个LLM代理（负责推理）完成。</li>
<li>执行由另一个LLM代理（负责调用工具）完成。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="使用-arXiv-工具"><a href="#使用-arXiv-工具" class="headerlink" title="使用 arXiv 工具"></a>使用 arXiv 工具</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> load_tools, initialize_agent, AgentType</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型和工具</span></span><br><span class="line">llm = ChatOpenAI(temperature=<span class="number">0.0</span>, model=os.environ.get(<span class="string">&quot;LLM_MODELEND&quot;</span>))</span><br><span class="line">tools = load_tools([<span class="string">&quot;arxiv&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化链</span></span><br><span class="line">agent_chain = initialize_agent(tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行链</span></span><br><span class="line">agent_chain.run(<span class="string">&quot;介绍一下2005.14165这篇论文的创新点?&quot;</span>)</span><br><span class="line"><span class="comment"># Thought: 论文的创新点是在少样本学习设置下测试了 GPT-3 的性能，发现扩大语言模型的规模可以极大地提高任务无关的少样本性能，有时甚至可以与之前最先进的微调方法竞争。</span></span><br></pre></td></tr></table></figure>


<p><a target="_blank" rel="noopener" href="https://python.langchain.com/docs/integrations/tools/">LangChain中集成的所有工具</a></p>
<h2 id="RAG-应用架构"><a href="#RAG-应用架构" class="headerlink" title="RAG 应用架构"></a>RAG 应用架构</h2><blockquote>
<p><code>Retrieval-Augmented Generation</code>，即检索增强生成，它结合了检索和生成的能力，为文本序列生成任务引入外部知识。RAG将传统的语言生成模型与大规模的外部知识库相结合，使模型在生成响应或文本时可以动态地从这些知识库中检索相关信息。</p>
</blockquote>
<p>数据源 - 大模型应用 - 用例</p>
<p>数据处理管道（Pipeline）</p>
<ol>
<li>Loading：文档加载器把 Documents 加载为以LangChain能够读取的形式。</li>
<li>Splitting：文本分割器把 Documents 切分为指定大小的分割，我把它们称为“文档块”或者“文档片”。</li>
<li>Storage：将上一步中分割好的“文档块”以“嵌入”（Embedding）的形式存储到向量数据库（Vector DB）中，形成一个个的“嵌入片”。</li>
<li>Retrieval：应用程序从存储中检索分割后的文档（例如通过比较余弦相似度，找到与输入问题类似的嵌入片）。</li>
<li>Synthesis：把问题和相似的嵌入片传递给语言模型（LLM），使用包含问题和检索到的分割的提示生成答案。</li>
</ol>
<p>我们使用了 <code>OpenAIEmbeddings</code> 来生成嵌入，然后使用 <code>Qdrant</code> 这个向量数据库来存储嵌入</p>
<p>词嵌入（Word Embedding）：将文本编码成向量。</p>
<blockquote>
<p>LangChain中的 <code>Embeddings</code> 类是设计用于与文本嵌入模型交互的类。这个类为所有这些提供者提供标准接口。</p>
</blockquote>
<ol>
<li><code>embed_documents</code> 方法，为文档创建嵌入。接收多个文本作为输入，意味着你可以一次性将多个文档，即被搜索的内容，转换为它们的向量表示。</li>
<li><code>embed_query</code> 方法，为查询创建嵌入。只接收一个文本作为输入，通常是用户的搜索查询。</li>
</ol>
<h3 id="存储嵌入"><a href="#存储嵌入" class="headerlink" title="存储嵌入"></a>存储嵌入</h3><p><code>CacheBackedEmbeddings</code>：将嵌入缓存在键值存储中。</p>
<p><strong>通过向量数据库（Vector Store）来保存</strong></p>
<p>非结构化查询：</p>
<p>通过向量存储检索器 <code>VectorstoreIndexCreator</code> 创建索引，在索引的 <code>query</code> 方法中，通过 <code>vectorstore</code> 类的 <code>as_retriever</code> 方法完成检索任务。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入文档加载器模块，并使用 TextLoader 来加载文本文件</span></span><br><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> TextLoader</span><br><span class="line">loader = TextLoader(<span class="string">&#x27;LangChainSamples/OneFlower/易速鲜花花语大全.txt&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 VectorstoreIndexCreator 来从加载器创建索引</span></span><br><span class="line"><span class="keyword">from</span> langchain.indexes <span class="keyword">import</span> VectorstoreIndexCreator</span><br><span class="line">index = VectorstoreIndexCreator().from_loaders([loader])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义查询字符串, 使用创建的索引执行查询</span></span><br><span class="line">query = <span class="string">&quot;玫瑰花的花语是什么？&quot;</span></span><br><span class="line">result = index.query(llm, query)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 打印查询结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> CharacterTextSplitter</span><br><span class="line"><span class="comment"># 进行文本分割</span></span><br><span class="line">text_splitter = CharacterTextSplitter(chunk_size=<span class="number">1000</span>, chunk_overlap=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Qdrant</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带有 Qdrant 的向量索引创建器</span></span><br><span class="line">index_creator = VectorstoreIndexCreator(</span><br><span class="line">    vectorstore_cls=Qdrant,</span><br><span class="line">    embedding,</span><br><span class="line">    text_splitter=CharacterTextSplitter(chunk_size=<span class="number">1000</span>, chunk_overlap=<span class="number">0</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>一种高效地管理和定位文档信息的方法，确保每个文档具有唯一标识并便于检索。</p>
<blockquote>
<p>LangChain 利用了记录管理器（RecordManager）来跟踪哪些文档已经被写入向量存储。</p>
<p>在进行索引时，API 会对每个文档进行哈希处理，确保每个文档都有一个唯一的标识。这个哈希值不仅仅基于文档的内容，还考虑了文档的元数据。确保了即使文档经历了多次转换或处理，也能够精确地跟踪它的状态和来源，确保文档数据被正确管理和索引。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://python.langchain.com/docs/how_to/indexing/">LangChain中 Indexing 的说明</a></p>
<h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h3><p>检索：</p>
<ul>
<li>MRR (Mean Reciprocal Rank)：平均倒数排名，是衡量检索结果质量的指标。相关结果首次出现的位置</li>
<li>Hit rate：检索到的文档中，正确答案的比例。</li>
<li>NDCG (Normalized Discounted Cumulative Gain)：归一化折扣累积增益，是衡量检索结果质量的指标。</li>
</ul>
<p>生成：</p>
<ul>
<li>BLEU (Bilingual Evaluation Understudy)：双语评估，是衡量生成结果质量的指标。</li>
<li>ROUGE (Recall-Oriented Understanding Evaluation)：重叠式理解评估，是衡量生成结果质量的指标。<ul>
<li>Rouge-L: L 表示最大匹配长度，衡量生成结果与参考答案的相似度。</li>
<li>Rouge-1: 单词匹配度。</li>
<li>Rouge-2: 短语匹配度。</li>
</ul>
</li>
</ul>
<h2 id="Agent-框架"><a href="#Agent-框架" class="headerlink" title="Agent 框架"></a>Agent 框架</h2><p>让ChatGPT自己生成这些引导文本</p>
<h4 id="模拟代理"><a href="#模拟代理" class="headerlink" title="模拟代理"></a>模拟代理</h4><p><strong>CAMEL 交流式代理</strong></p>
<p>交流式代理 + 角色扮演 + 启示式提示 <code>inception prompting</code></p>
<p>明确的交互规范，如一次只能给出一个指令，解决方案必须具有详细的解释。使用 “Solution: ” 开始输出解决方案，等等。有助于保持对话的清晰性和高效性。</p>
<blockquote>
<p>CAMEL中提示的设计更加复杂和细致，更像是一种交互协议或规范。这种设计在一定程度上提高了AI与AI之间自主合作的能力，并能更好地模拟人类之间的交互过程。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2303.17760">CAMEL：用于大规模语言模型社会的“心智”探索的交流式代理</a></p>
<h4 id="自主代理"><a href="#自主代理" class="headerlink" title="自主代理"></a>自主代理</h4><p>能够在无需外部干预的情况下自主运行，这在真实世界的应用中具有巨大的价值。</p>
<ul>
<li><code>Auto-GPT</code>: 自动链接多个任务。多步提示过程，将目标分解为子任务。</li>
<li><code>BabyAGI</code>: 自动生成和执行任务，而且还可以根据完成的任务结果生成新任务，并且可以实时确定任务的优先级。</li>
<li><code>HuggingGPT</code>: 自动生成计划，并处理多个复杂的AI任务。允许HuggingGPT持续接入。</li>
</ul>
<p>BabyAGI 完成任务过程：</p>
<blockquote>
<p>向系统提出一个目标之后，它将不断优先考虑需要实现或完成的任务，以实现该目标。具体来说，系统将形成任务列表，从任务列表中拉出优先级最高的第一个任务，使用 OpenAI API 根据上下文将任务发送到执行代理并完成任务，一旦这些任务完成，它们就会被存储在内存（或者Pinecone这类向量数据库）中，然后，根据目标和上一个任务的结果创建新任务并确定优先级。 </p>
</blockquote>
<p><img src="/image/07cbca8cfff33ffa231830eff145556c.webp" alt="alt text"></p>
<p>HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in Hugging Face</p>
<p>使其能够根据用户请求自动生成计划，并使用外部模型，从而整合多模态感知能力，并处理多个复杂的AI任务。此外，这种流程还允许HuggingGPT持续从任务特定的专家模型中吸收能力，从而实现可增长和可扩展的AI能力。</p>
<h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2010.10439v2">开放式表格与文本问题回答</a>，Chen, W., Chang, M.-W., Schlinger, E., Wang, W., &amp; Cohen, W. W. (2021). Open Question Answering over Tables and Text. ICLR 2021.</p>
</li>
<li><p>Open AI的GPT-3模型：<a target="_blank" rel="noopener" href="https://proceedings.neurips.cc/paper_files/paper/2020/file/1457c0d6bfcb4967418bfb8ac142f64a-Paper.pdf">大模型是少样本学习者</a>, Brown, T. B., Mann, B., Ryder, N., Subbiah, M., Kaplan, J., Dhariwal, P., … &amp; Agarwal, S. (2020). Language models are few-shot learners. arXiv preprint arXiv:2005.14165.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2109.01652">微调后的语言模型是零样本学习者</a>, Wei, J., Bosma, M., Zhao, V. Y., Guu, K., Yu, A. W., Lester, B., Du, N., Dai, A. M., &amp; Le, Q. V. (2022). Finetuned Language Models Are Zero-Shot Learners. Proceedings of the International Conference on Learning Representations (ICLR 2022).</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2202.12837">对示例角色的重新思考：是什么使得上下文学习有效？</a>, Min, S., Lyu, X., Holtzman, A., Artetxe, M., Lewis, M., Hajishirzi, H., &amp; Zettlemoyer, L. (2022). Rethinking the Role of Demonstrations: What Makes In-Context Learning Work? Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing (EMNLP 2022).</p>
</li>
<li><p>2022 年，在 Google 发布的论文 <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2201.11903">Chain-of-Thought Prompting Elicits Reasoning in Large Language Models</a>中首次提出思维链（Chain of Thought），Wang, X., Wei, J., Schuurmans, D., Le, Q., Chi, E., Narang, S., Chowdhery, A., &amp; Zhou, D. (2023). Self-Consistency Improves Chain of Thought Reasoning in Language Models. Proceedings of the International Conference on Learning Representations (ICLR). arXiv preprint arXiv:2203.11171.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2305.10601">论文，思维之树：使用大型语言模型进行深思熟虑的问题解决</a>，Yao, S., Yu, D., Zhao, J., Shafran, I., Griffiths, T. L., Cao, Y., &amp; Narasimhan, K. (2023). Tree of Thoughts: Deliberate Problem Solving with Large Language Models. arXiv preprint arXiv:2305.10601.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2210.03629">ReAct：在语言模型中协同推理和行动</a>，Yao, S., Zhao, J., Yu, D., Du, N., Shafran, I., Narasimhan, K., &amp; Cao, Y. (2023). ReAct: Synergizing Reasoning and Acting in Language Models. arXiv preprint arXiv:2210.03629</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2303.09014">ART：大型语言模型的自动多步推理和工具使用</a>，Paranjape, B., Lundberg, S., Singh, S., Hajishirzi, H., Zettlemoyer, L., &amp; Ribeiro, M. T. (2023). ART: Automatic multi-step reasoning and tool-use for large language models. arXiv preprint arXiv:2303.09014.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2305.04091">“计划与解决”提示：通过大型语言模型改进Zero-Shot链式思考推理</a> Wang, L., Xu, W., Lan, Y., Hu, Z., Lan, Y., Lee, R. K.-W., &amp; Lim, E.-P. (2023). Plan-and-Solve Prompting: Improving Zero-Shot Chain-of-Thought Reasoning by Large Language Models. arXiv preprint arXiv:2305.04091.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2205.11916">Large Language Models are Zero-Shot Reasoners</a></p>
</li>
<li><p>论文 <a href="https://link.juejin.cn/?target=https://arxiv.org/pdf/2303.17580.pdf" title="https://arxiv.org/pdf/2303.17580.pdf">HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in Hugging Face</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2312.10997">Retrieval-Augmented Generation for Large Language Models: A Survey</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2305.14283">Query Rewriting for Retrieval-Augmented Large Language Models</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiangyu.github.io/2024/11/09/%E4%BD%BF%E7%94%A8LangChain%E6%9E%84%E5%BB%BALLMs%E5%BA%94%E7%94%A8/" data-id="cmc102333000jc0vz9fcngjmf" data-title="使用LangChain构建LLMs应用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-理解与使用CSS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/08/%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8CSS/" class="article-date">
  <time class="dt-published" datetime="2024-11-08T06:34:44.000Z" itemprop="datePublished">2024-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/08/%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8CSS/">理解与使用CSS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Cascading Style Sheet，层叠样式表: 渲染外观</p>
<p>W3C标准: <a target="_blank" rel="noopener" href="https://www.w3.org/Style/CSS/">https://www.w3.org/Style/CSS/</a></p>
<h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><ul>
<li><p><strong>内嵌式</strong>: style标签中, 位置在<code>&lt;head&gt;</code>内</p>
<p>当前页面 小案例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>外联式</strong>: 单独.css文件中</p>
<p>作用多个页面 较大项目</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>行内式</strong>: 在标签的属性里</p>
<p>仅一个标签：配合js使用</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: blue; font-size: 20px;&quot;</span>&gt;</span>div content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>属性名: 属性值;</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    * &#123; </span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.red</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#one</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font</span>: <span class="number">2em</span> sans-serif;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p 标签选择器<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>div 类选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span>&gt;</span>div 标签选择器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<ul>
<li>标签选择器：<code>p &#123; &#125;</code> 选择<strong>所有此类标签</strong>, 无论多少层嵌套</li>
<li>类选择器：<code>.red &#123; &#125;</code> 类名可重复 多个类名用空格隔开</li>
<li>id选择器：<code>#one &#123; &#125;</code> 唯一对应id，仅选中一个标签</li>
<li>属性选择器：<code>E[att] &#123; &#125;</code> 具有 att 特性的 E 元素<ul>
<li><code>E[att=val] &#123; &#125;</code> att 值为 val 的元素</li>
<li><code>E[att~=val]</code> , <code>E[att|=&quot;val&quot;]</code>, <code>E[att^=&quot;val&quot;]</code>, <code>E[att$=&quot;val&quot;]</code>, <code>E[att*=&quot;val&quot;]</code></li>
</ul>
</li>
<li>通配符：<code>* &#123; &#125;</code> 选择所有元素</li>
<li>后代选择器：<code>pn child &#123; &#125;</code> 对于<strong>所有后代</strong> 空格隔开<ul>
<li>子代：<code>pn&gt;son &#123; &#125;</code> 仅选儿子</li>
</ul>
</li>
<li>兄弟选择器：<code>E~F &#123; &#125;</code> E 之后的所有 F 兄弟元素<ul>
<li>相邻：<code>E+F &#123; &#125;</code> E 之后的第一个 F 元素，如果 F 元素不是 E 元素的后一个兄弟元素，则选择不成功。</li>
</ul>
</li>
<li>并集：<code>.red, .two &#123; &#125;</code> 逗号隔开</li>
<li>交集：<code>p.red &#123; &#125;</code> 无空格分隔</li>
</ul>
<p>伪类: <code>:hover</code> 鼠标悬浮状态</p>
<p>简写：<strong>emmet语法</strong></p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ol>
<li>样式表来源<ul>
<li>浏览器默认 &lt; 用户样式 &lt; 作者样式（主要的） &lt; 作者样式 <code>!important</code> &lt; 浏览器默认 <code>!important</code> &lt; 浏览器默认 <code>!important</code></li>
</ul>
</li>
<li>选择器优先级<ul>
<li>内联 &gt; id &gt; class &#x3D; attribute &#x3D; pseudo-class &gt; type &#x3D; pseudo-element</li>
</ul>
</li>
<li>源码位置<ul>
<li>最后声明的生效</li>
<li>与 <code>class=&quot;red green&quot;</code> 引用顺序无关</li>
</ul>
</li>
</ol>
<p>少用 <code>id</code> 与 <code>!important</code></p>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><ul>
<li>内容区：内容 + 内边距 + 边框 + 外边距</li>
</ul>
<blockquote>
<p>只有 margintop 和 marginbottom 可以为负值，其他的都不能为负值。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  三角形  */</span></span><br><span class="line"><span class="selector-class">.triangle-bottom</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  固定比例矩形  */</span></span><br><span class="line"><span class="selector-class">.ratio-box</span>&#123;</span><br><span class="line">    <span class="comment">/* 新特性写法 */</span></span><br><span class="line">    <span class="comment">/* aspect-ratio: 4 / 3;</span></span><br><span class="line"><span class="comment">    background-color: greenyellow; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">background-color</span>: cadetblue;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 是父元素宽度的75% */</span></span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">75%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 渐变边框 */</span></span><br><span class="line"><span class="selector-class">.awesome-border</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">8px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">background-clip</span>: padding-box,border-box;</span><br><span class="line">    <span class="attribute">background-origin</span>: padding-box,border-box;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right,<span class="number">#fff</span>,<span class="number">#fff</span>),<span class="built_in">linear-gradient</span>(<span class="number">135deg</span>,<span class="number">#e941ab</span>,<span class="number">#a557ef</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<ul>
<li><code>box-sizing: border-box;</code> 宽度计算包含边框宽度</li>
<li><code>box-sizing: content-box;</code> 宽度计算不包含边框宽度</li>
</ul>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h4 id="常规流"><a href="#常规流" class="headerlink" title="常规流"></a>常规流</h4><p>默认情况下，浏览器会从上到下、从左到右地排列块级元素和行内元素。</p>
<p>相邻的块级元素之间会自动产生垂直间距（margin），这称为“外边距合并（margin collapsing）”。</p>
<ul>
<li>块级元素：独占一行，宽度默认100%，高度默认由内容撑开。<ul>
<li>包括 <code>&lt;div&gt;</code>、<code>&lt;h1&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;ul&gt;</code></li>
<li><code>display: block;</code></li>
<li>环境：BFC（Block Formatting Context）</li>
</ul>
</li>
<li>行内元素：水平排列，高度默认由内容撑开<ul>
<li>包括 <code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code></li>
<li><code>display: inline;</code></li>
<li>环境：IFC（Inline Formatting Context）</li>
</ul>
</li>
</ul>
<p>外边距塌陷：两个相邻&#x2F;嵌套&#x2F;空的块级元素的外边距相遇时，它们的外边距会合并取其中较大的一个值，而不是叠加。通过添加 <code>Padding</code> 或 <code>Border</code> 解决，或设置父元素为BFC。</p>
<p>内联格式中 <code>line-height</code> 和 height 设置为相同的高度实现对齐</p>
<p>各种内联元素对比：</p>
<ul>
<li><code>inline</code>: <code>&lt;span&gt;</code> 的默认样式，不接受宽度和高度（由内容决定），不换行。</li>
<li><code>inline-block</code>: 可以设置宽高（默认由内容撑开），不换行。可以与 inline 元素在同一行排列，控制其上下边距。</li>
<li><code>block</code>: 有换行，默认宽度100%，高度默认由内容撑开。</li>
</ul>
<p>行内元素对齐方式：</p>
<ul>
<li><code>text-align: baseline;</code>: 基线</li>
<li><code>text-align: middle;</code>: 居中</li>
</ul>
<h4 id="Flexbox-弹性盒子"><a href="#Flexbox-弹性盒子" class="headerlink" title="Flexbox 弹性盒子"></a>Flexbox 弹性盒子</h4><p>一维布局：灵活的响应式设计。</p>
<ul>
<li>容器：<code>display: flex;</code></li>
<li>子元素：<code>display: flex;</code> 或 <code>display: inline-flex;</code></li>
</ul>
<h4 id="grid-二维网格"><a href="#grid-二维网格" class="headerlink" title="grid 二维网格"></a>grid 二维网格</h4><p>基于布局，适合复杂的较大页面。</p>
<p><code>display: grid</code>; 或 <code>display: inline-grid;</code></p>
<ul>
<li>创建网格：<code>grid-template-columns: 1fr 1fr;</code></li>
<li>子元素：<code>grid-column: 1 / 3;</code></li>
</ul>
<p>网格线：</p>
<ul>
<li><code>grid-column-start</code></li>
<li><code>grid-column-end</code></li>
<li><code>grid-row-start</code></li>
<li><code>grid-row-end</code></li>
<li><code>grid-column</code></li>
<li><code>grid-row</code></li>
<li><code>grid-area</code></li>
</ul>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p><code>position</code> 属性</p>
<ul>
<li><code>static</code> 默认值，元素出现在正常的流中。</li>
<li><code>relative</code> 相对定位，相对于元素本身进行定位。</li>
<li><code>absolute</code> 绝对定位，相对于最近的已定位祖先元素。</li>
<li><code>fixed</code> 固定定位，相对于浏览器窗口进行定位， 不受滚动影响。</li>
<li><code>sticky</code> 粘性定位，相对于最近的已定位祖先元素，当元素进入视口时，固定在顶部或底部。</li>
</ul>
<h4 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h4><p>staking context：将元素沿着垂直屏幕的虚构的 Z 轴排开。</p>
<ul>
<li>可包含在其他层叠上下文中。</li>
<li>独立于兄弟元素，只考虑子元素。</li>
<li>子元素的z-index无法超越父元素的z-index显示顺序。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flow_layout/Introduction_to_formatting_contexts">渲染过程</a></p>
<p>形成条件：</p>
<ul>
<li>文档根元素 <code>&lt;html&gt;</code>。</li>
<li><code>position: relative;</code> 或 <code>position: absolute;</code> 的元素, z-index 值不为默认值。</li>
<li><code>position: fixed;</code>, <code>position: sticky;</code> 的元素。</li>
<li><code>flex</code>, <code>grid</code></li>
<li><code>opacity</code> 值小于 1 的元素。</li>
<li>具有 <code>transform</code>, <code>filter</code>, <code>backdrop-filter</code>, <code>perspective</code>, <code>clip-path</code>, <code>mask</code>, <code>isolation</code> 属性的元素。</li>
</ul>
<p>同一个层叠上下文内，元素间也有顺序:<br><img src="/cfea9c5cd49944f89ff52845563233f1~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="alt text"></p>
<blockquote>
<p>使用 CSS 变量或预处理语言的变量来管理 z-index 的值。将预设间隔设置为 10 或 100，以便后续便于插入。</p>
</blockquote>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>计算布局 -&gt; 绘制 -&gt; 合成</p>
<p>触发 reflow 的情况：</p>
<ol>
<li>修改 DOM 元素</li>
<li>更改样式</li>
<li>调整浏览器窗口大小</li>
</ol>
<p>需要 CPU 负责重新计算元素的大小、位置和布局。应该尽量不触发。</p>
<p><strong>合成层（Composition Layers）</strong></p>
<p>由GPU处理，将多个图层合成一个独立的图层中：减少绘制次数，提升渲染效率。</p>
<p>使用 transform、opacity 等属性时，变化只需要由GPU重绘合成层中单独的图层，在后台运行。</p>
<p><a target="_blank" rel="noopener" href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome/">关于GPU硬件加速渲染详解</a></p>
<h4 id="transform-变形"><a href="#transform-变形" class="headerlink" title="transform 变形"></a>transform 变形</h4><p>2d</p>
<p>3D变形</p>
<p>在线试一试： <a target="_blank" rel="noopener" href="https://codepen.io/yao-mo/pen/YzjYLeO">codepen.io&#x2F;yao-mo&#x2F;pen&#x2F;…</a></p>
<h4 id="transition-过渡"><a href="#transition-过渡" class="headerlink" title="transition 过渡"></a>transition 过渡</h4><p><code>property</code> 过渡属性 + <code>duration</code> 过渡时间 + <code>timing-function</code> 过渡函数 + <code>delay</code> 延迟时间</p>
<p>三种过渡函数：</p>
<ul>
<li><code>linear</code> 线性</li>
<li>贝塞尔曲线<ul>
<li><code>ease</code> 缓动 </li>
<li><code>ease-in-out</code></li>
<li><code>cubic-bezier(n,n,n,n)</code> 自定义</li>
</ul>
</li>
<li><code>steps(n, start|end)</code> 分段函数阶跃</li>
</ul>
<h4 id="animation-动画"><a href="#animation-动画" class="headerlink" title="animation 动画"></a>animation 动画</h4><p>animation 属性参考：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/animation">developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;…</a></p>
<p>关键帧</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 动画名称 &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="comment">/* 开始状态 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="comment">/* 结束状态 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>animation-name</code>: 关键帧名称</li>
<li><code>animation-duration</code>: 持续时间</li>
<li><code>animation-timing-function</code>: 节奏</li>
<li><code>animation-delay</code>: 延迟开始时间</li>
<li><code>animation-iteration-count</code>: 重复次数</li>
<li><code>animation-direction</code>: 反向&#x2F;交替</li>
<li><code>animation-fill-mode</code>: 执行前后样式</li>
<li><code>animation-play-state</code>: 运行状态</li>
</ul>
<h2 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h2><p>原则：</p>
<ul>
<li>优先选用流式布局，如百分比、<code>flex</code>、 <code>grid</code>等</li>
<li>使用响应式图片，匹配尺寸，节省带宽</li>
<li>使用媒体查询为不同的设备类型做适配</li>
<li>给移动端设备设置简单、统一的视口</li>
<li>使用相对长度，<code>em</code>、<code>rem</code>、<code>vw</code> 做为长度度量</li>
</ul>
<h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>根据不同的设备特性（如屏幕大小、分辨率、方向等）应用不同的样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">    <span class="comment">/* 针对屏幕宽度大于768px的设备 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">767px</span>) &#123;</span><br><span class="line">    <span class="comment">/* 针对屏幕宽度小于768px的设备 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1023px</span>) &#123;</span><br><span class="line">    <span class="comment">/* 针对屏幕宽度介于768px和1023px之间的设备 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1024px</span>) &#123;</span><br><span class="line">    <span class="comment">/* 针对屏幕宽度大于1024px的设备 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-width</span>: <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">max-device-width</span>: <span class="number">1024px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>: portrait) &#123;</span><br><span class="line">    <span class="comment">/* 针对竖屏设备 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-width</span>: <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">max-device-width</span>: <span class="number">1024px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;</span><br><span class="line">    <span class="comment">/* 针对横屏设备 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遵循cascading层叠覆盖原则，尽量将一般样式放在前面，特定样式放在后面。</p>
<h4 id="像素与尺寸设计"><a href="#像素与尺寸设计" class="headerlink" title="像素与尺寸设计"></a>像素与尺寸设计</h4><p>确保阅读体验是相对一致</p>
<ul>
<li>视觉尺寸：1px &#x3D; 1&#x2F;96英寸</li>
<li>CSS像素：1px &#x3D; 0.75pt</li>
<li>设备像素比：DPR &#x3D; 设备像素&#x2F;CSS像素</li>
</ul>
<p>移动端设备viewport的适配:</p>
<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></p>
<ul>
<li><code>em</code> 表示相对于使用它的元素的字体大小。</li>
<li><code>rem</code> 为相对于根元素（<code>&lt;html&gt;</code>）的字体大小。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1em = 16px */</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;  </span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="comment">/* 根元素字体大小 */</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="selector-class">.element</span> &#123;  </span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2rem</span>; <span class="comment">/* 该元素的字体大小为 32px (16px * 2) */</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="selector-class">.child</span> &#123;  </span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2rem</span>; <span class="comment">/* 该元素的字体大小仍然为 32px */</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.paragraph</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1em</span>; <span class="comment">/* 1em = 16px */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0.5em</span>; <span class="comment">/* 0.5em = 8px */</span></span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5em</span>; <span class="comment">/* 24px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置rem为视口宽度的10%，等比缩放。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setRem</span>(<span class="params">ratio</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> rem = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span> / ratio;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>vw</code> 视窗宽度的百分比，视窗宽度为视口宽度的100%。<code>vh</code> 视窗高度的百分比。</li>
</ul>
<h2 id="CSS-工程化"><a href="#CSS-工程化" class="headerlink" title="CSS 工程化"></a>CSS 工程化</h2><p>语言增强-CSS预处理器</p>
<ul>
<li>自定义变量</li>
<li>嵌套选择器、作用域</li>
<li>循环、条件语句、定义函数</li>
<li>mixins、继承</li>
</ul>
<h4 id="CSS-模块化"><a href="#CSS-模块化" class="headerlink" title="CSS 模块化"></a>CSS 模块化</h4><p>BEM命名法 <code>block__element--modifier</code>：</p>
<ul>
<li>Element：模块的组成部分，如header__title、container__item等</li>
<li>Block：模块的名称，如header、container等</li>
<li>Modifier：模块的状态或属性，如header–fixed、container–center等</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组件 */</span></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 子组件 */</span></span><br><span class="line"><span class="selector-class">.header__title</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修饰符 */</span></span><br><span class="line"><span class="selector-class">.header--fixed</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>CSS in JS: 将应用的CSS样式写在JavaScript文件里面，利用js动态生成css。</p>
<p>unique classname</p>
<p>styled component 机制：第二个 classname 作为唯一类名（hash 值），写入 class.</p>
<ul>
<li>首屏渲染、无多余css阻塞</li>
</ul>
<h4 id="原子化-CSS"><a href="#原子化-CSS" class="headerlink" title="原子化 CSS"></a>原子化 CSS</h4><ul>
<li>工具库优先</li>
<li>组合使用</li>
<li>简单的类名</li>
</ul>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>AST抽象语法树格式化网址：<a target="_blank" rel="noopener" href="https://astexplorer.net/">astexplorer.net&#x2F;</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiangyu.github.io/2024/11/08/%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8CSS/" data-id="cmc102335000pc0vz1804hr55" data-title="理解与使用CSS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E5%9F%BA%E7%A1%80/">代码基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%B2%BB/" rel="tag">分治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" rel="tag">前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%8B%9F/" rel="tag">模拟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%88%86%E6%B2%BB/" style="font-size: 10px;">分治</a> <a href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" style="font-size: 10px;">前缀和</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 20px;">双指针</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 15px;">字符串</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 10px;">模拟</a> <a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 15px;">滑动窗口</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 15px;">贪心</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/18/lc/11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/">11盛最多水的容器</a>
          </li>
        
          <li>
            <a href="/2025/06/18/lc/42%E6%8E%A5%E9%9B%A8%E6%B0%B4/">42接雨水</a>
          </li>
        
          <li>
            <a href="/2025/06/17/lc/3170%E5%88%A0%E9%99%A4%E6%98%9F%E5%8F%B7%E4%BB%A5%E5%90%8E%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/">3298统计重新排列后包含另一个字符串的子字符串数目</a>
          </li>
        
          <li>
            <a href="/2025/01/18/lc/%E4%BC%98%E8%B4%A8%E7%AB%A0%E8%8A%82%E8%BF%9E%E7%BB%AD%E9%80%89%E6%8B%A9/">优质章节连续选择</a>
          </li>
        
          <li>
            <a href="/2025/01/11/lc/76%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/">76最小覆盖子串</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Alexiang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>